# AI 编程最佳实践指南

> 本文档详细说明如何更有效地使用 AI 编程助手，避免常见陷阱。

---

## 一、提供充足的项目上下文

AI 缺乏全局观的根本原因是「信息不对称」。解决方案是在对话中提供充足的项目背景。

### 1.1 需要提供的信息清单

| 信息类型 | 说明 | 示例 |
|---------|------|------|
| 项目目录结构 | 核心模块的位置和职责 | `core/css/` 负责 CSS 解析 |
| 技术栈约束 | 使用的框架、语言标准 | C++17、CMake、Google Test |
| 已有公共模块 | 工具类、日志系统、错误处理 | `utils/logger.h`、`utils/error_code.h` |
| 第三方依赖 | 已集成的库及其用途 | RapidJSON 用于 JSON 解析 |
| 构建系统 | 构建命令和配置方式 | `cmake --build . --target mylib` |

### 1.2 项目结构示例

参考 [Google-CPP-软件架构师角色定义.md](./Google-CPP-软件架构师角色定义.md) 中的项目结构：

```
project/
├── include/                    # 公共头文件
│   ├── core/                   # 核心模块头文件
│   ├── tools/                  # 工具类头文件
│   └── utils/                  # 通用工具头文件
├── src/                        # 源代码实现
├── tests/                      # 测试代码
│   ├── unit/                   # 单元测试
│   └── integration/            # 集成测试
├── third_party/                # 第三方依赖
└── docs/                       # 文档
```

> 💡 **提示**：在使用 AI 助手前，准备一份项目概览文档（如 `RULES.md`），包含目录结构、模块职责、公共依赖等信息，每次对话时引用即可。

---

## 二、明确编码规范要求

避免 AI「自由发挥」的关键是**提前约定规范**。

### 2.1 命名规范

明确告知 AI 项目使用的命名风格（参考 [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html)）：

```cpp
// 类名：PascalCase
class TableStyleManager;

// 函数名：PascalCase（Google 风格）
void ComputeStyle();
int GetRowCount();

// 变量名：snake_case
int row_count;

// 成员变量：带后缀
class MyClass {
    int value_;       // _ 后缀（Google 风格）
};

// 常量：k 前缀 + PascalCase
const int kMaxBufferSize = 1024;
```

### 2.2 格式规范

```cpp
// 缩进：4 空格
// 大括号：K&R 风格
if (condition) {
    DoSomething();
} else {
    DoOther();
}

// 行长度：不超过 120 字符
```

### 2.3 头文件规范

```cpp
// Include 顺序：
// 1. 对应的头文件
// 2. C 系统头文件
// 3. C++ 标准库
// 4. 第三方库
// 5. 项目内部头文件

#include "my_class.h"
#include <cstdint>
#include <string>
#include <rapidjson/document.h>
#include "utils/logger.h"
```

### 2.4 规范清单模板

向 AI 提供一份简洁的规范清单：

```markdown
## 编码规范要求
- 命名风格：Google C++ Style
- 缩进：4 空格
- 日志：使用项目日志宏（如 `LOG_INFO`），不要用 print/cout
- 错误处理：使用 `std::optional` 或 `Expected<T, E>`
- 智能指针：优先 `unique_ptr`，需要共享时用 `shared_ptr`
- 已有工具类：`utils/string_utils.h`（字符串处理）
```

---

## 三、分步骤进行复杂任务

AI 适合处理边界清晰的小任务，复杂任务需要拆分。

### 3.1 任务拆分原则

```
❌ 错误示范：
   "帮我实现一个完整的 CSS 解析器"

✅ 正确做法：
   1. "先设计 CSS 解析器的接口定义（.h 文件）"
   2. "实现 CSS 选择器的解析逻辑"
   3. "实现 CSS 属性值的解析逻辑"
   4. "为解析器编写单元测试"
```

### 3.2 每步检查点

- [ ] 生成的代码是否符合命名规范？
- [ ] 是否复用了已有的工具函数？
- [ ] 是否与项目中的类似实现保持一致？
- [ ] 接口设计是否合理？

### 3.3 使用 OpenSpec 进行设计先行

对于复杂任务，建议使用 **OpenSpec** 规范编写设计文档，确保在编码前完成充分的设计和评审。

#### 3.3.1 何时需要 OpenSpec

| 场景 | 说明 | 示例 |
|------|------|------|
| **新模块开发** | 从零开始的模块需要明确接口和职责 | 新增 CSS 解析器模块 |
| **跨模块交互** | 涉及多个模块协作的功能 | 文档加载流程重构 |
| **API 设计** | 对外暴露的公共接口 | 插件系统 API 设计 |
| **架构变更** | 影响系统整体结构的修改 | 引入异步处理机制 |
| **复杂算法** | 需要详细说明算法逻辑和边界条件 | 表格合并单元格计算 |
| **性能关键路径** | 需要明确性能目标和优化策略 | 大文件解析优化 |

#### 3.3.2 OpenSpec 文档结构

```markdown
# [模块/功能名称] 设计文档

## 1. 概述
- 背景和目标
- 问题域描述

## 2. 需求分析
- 功能需求
- 非功能需求（性能、可扩展性等）
- 约束条件

## 3. 接口设计
- 公共接口定义（.h 文件）
- 输入/输出规范
- 错误处理策略

## 4. 详细设计
- 类图/模块图
- 核心数据结构
- 关键算法说明
- 状态机（如适用）

## 5. 测试策略
- 单元测试范围
- 集成测试场景
- 边界条件测试

## 6. 风险评估
- 已知风险及缓解措施
- 兼容性影响
```

#### 3.3.3 设计文档审核流程

> ⚠️ **重要**：所有 OpenSpec 设计文档必须经过 **软件架构师** 审核后方可进入编码阶段。

审核标准参考 [Google-CPP-软件架构师角色定义.md](./Google-CPP-软件架构师角色定义.md) 中的架构评审职责：

| 审核维度 | 审核要点 |
|----------|----------|
| **架构合理性** | 模块职责是否单一？依赖关系是否合理？是否存在循环依赖？ |
| **接口设计** | 接口是否简洁清晰？是否易于使用和扩展？是否符合现有设计风格？ |
| **技术选型** | 技术方案是否合理？是否与项目现有技术栈一致？ |
| **性能考量** | 是否满足性能要求？是否有明显的性能瓶颈？ |
| **可测试性** | 设计是否支持有效的测试策略？ |
| **安全性** | 是否存在安全风险？输入验证是否充分？ |

**审核流程**：

```
1. 开发者编写 OpenSpec 设计文档
       ↓
2. 提交设计文档至 docs/specs/ 或 specs/ 目录
       ↓
3. 软件架构师进行设计评审
       ↓
4. 根据反馈修改设计文档（可能多轮迭代）
       ↓
5. 架构师批准后，开始编码实现
       ↓
6. 实现完成后，进行代码审查（对照设计文档）
```

#### 3.3.4 AI 辅助设计的注意事项

使用 AI 辅助编写设计文档时：

```
❌ 错误示范：
   "帮我设计一个 CSS 解析器"
   
✅ 正确做法：
   1. "分析 CSS 解析器需要处理的输入格式和输出结构"
   2. "设计 CSS 解析器的核心类和接口"
   3. "列出 CSS 解析器需要考虑的边界条件和错误情况"
   4. "根据以上分析，生成 OpenSpec 格式的设计文档"
```

> 💡 **提示**：AI 生成的设计文档同样需要架构师审核。AI 可能缺乏对项目上下文的理解，容易忽略与现有系统的集成问题。

---

## 四、代码审查清单

AI 生成的代码**必须经过人工审查**。以下清单参考 [Google-CPP-软件架构师角色定义.md](./Google-CPP-软件架构师角色定义.md)。

### 4.1 架构审查

- [ ] 模块职责是否单一明确？
- [ ] 接口设计是否合理？
- [ ] 依赖关系是否正确？
- [ ] 是否存在循环依赖？

### 4.2 代码质量审查

- [ ] 命名是否清晰准确？
- [ ] 函数是否足够短小（理想 20-40 行）？
- [ ] 是否有重复代码（检查项目中是否已有类似实现）？
- [ ] 错误处理是否完善？
- [ ] 边界条件是否处理？

### 4.3 性能审查

- [ ] 是否有不必要的拷贝？（应使用 `std::move`、`string_view`）
- [ ] 是否有内存泄漏风险？（检查资源释放）
- [ ] 容器是否预分配了空间？（`reserve()`）

### 4.4 一致性审查（重点！）

- [ ] 日志输出是否使用了项目的日志系统？
- [ ] 错误处理是否与项目风格一致？
- [ ] 是否重复实现了已有的工具函数？
- [ ] 配置值是否硬编码？

---

## 五、项目级 AI 协作规范模板

**推荐做法：在项目根目录创建 `RULES.md` 或 `.cursorrules` 文件**

```markdown
# AI 编程助手使用规范

## 项目概览
- 项目名称：xxxreader
- 语言标准：C++17
- 构建系统：CMake

## 目录结构
- `include/` - 公共头文件
- `src/` - 源代码实现
- `tests/` - 测试代码
- `utils/` - 公共工具类（优先复用！）

## 已有公共模块（必须优先使用）
- 日志：`#include "utils/logger.h"`，使用 `LOG_INFO` / `LOG_ERROR`
- 字符串：`#include "utils/string_utils.h"`
- 错误码：`#include "utils/error_code.h"`

## 编码规范
- 命名：Google C++ Style
- 缩进：4 空格
- 智能指针：优先 unique_ptr
- 禁止：裸 new/delete、C 风格数组、魔法数字

## 禁止事项
- ❌ 不要使用 `cout`/`printf`，使用日志系统
- ❌ 不要重新实现字符串处理函数，使用 `string_utils.h`
- ❌ 不要硬编码配置值
```

---

## 六、快速参考卡片

| 场景 | 做法 |
|------|------|
| 开始新任务 | 引用项目规范文档（RULES.md） |
| 生成工具函数 | 先检查 `utils/` 是否已有类似实现 |
| 复杂功能 | 拆分为接口设计 → 实现 → 测试 |
| **新模块/API 设计** | **先用 OpenSpec 写设计文档，经架构师审核后再编码** |
| **跨模块功能** | **编写 OpenSpec 设计文档，明确接口和职责边界** |
| 代码审查 | 重点检查一致性和重复代码 |
| 设计文档审核 | 提交至 `docs/specs/`，由软件架构师审核批准 |
| 遇到问题 | 提供更多上下文，而非重复提问 |
